# EnvDataReader

**EnvDataReader** - универсальная библиотека, разработанная для эффективного управления переменными окружения и конфигурациями в ваших проектах. Она предоставляет интуитивно понятные инструменты для создания, управления и плавного переключения между различными настройками окружения, что значительно упрощает процесс разработки.

С помощью `EnvDataReader` вы легко сможете:

- Определять и управлять переменными окружения.
- Настраивать параметры подключения к различным сервисам и базам данных.
- Управлять настройками приложения в зависимости от текущего окружения (например, разработка, тестирование, продакшн).

Эта библиотека предлагает следующие преимущества:

- **Гибкость**: Легко адаптировать приложения к различным условиям работы без изменения кода.
- **Надежность**: Создание более надежных и масштабируемых приложений путем эффективного управления окружением с минимальными усилиями и максимальной эффективностью.

**EnvDataReader** дает разработчикам возможность создавать устойчивые приложения, упрощая управление окружением и обеспечивая адаптацию к различным операционным контекстам без лишних сложностей.

# Использование EnvDataReader

Для интеграции **envdatareader** в ваш проект выполните следующие шаги:

1. **Установка EnvDataReader:**
   Установите `EnvDataReader` через ваш менеджер пакетов. Например, если вы используете pip:

   PowerShell | CMD
   ```bash
   pip install envdatareader
   ```
   Linux
   ```bash
   pip3 install envdatareader
   ```

2. **Использование envdatareader:**
   
   После установки библиотеки, вы можете создать экземпляр `EnvDataReader` для управления вашими переменными окружения. Вот пример использования:

   ```python
    # Импортируем класс EnvDataReader из библиотеки envdatareader
    from envdatareader import EnvDataReader

    # Создаем экземпляр envdatareader без явного указания пути к файлу .env
    # По умолчанию будет считываться файл .env из корня проекта
    env = EnvDataReader()

    # Получаем значение переменной DP_HOST из файла .env и выводим его
    print(env.get_value("DP_HOST"))

   ```

   В этом примере `envdatareader` создается без явного указания пути к файлу .env. По умолчанию, `envdatareader` будет пытаться считать файл `.env` из корня проекта. Вы можете использовать метод get_value для извлечения значения конкретной переменной окружения, например, переменной `DP_HOST`.
   
   ---
   ```python
    from envdatareader import EnvDataReader

    # По умолчанию мы считываем файл `.env` из корня проекта. Однако, если ваш файл `.env` хранится в другом месте,
    # вы можете создать переменную с путем к файлу:

    custom_env_file_path = "env\\.env"

    # Для использования файла `.env`, расположенного в другом месте, создайте экземпляр envdatareader,
    # указав путь к файлу:

    env = EnvDataReader(file_path=custom_env_file_path)

    # Этот пример показывает, как указать путь к файлу `.env` вне корня проекта при создании экземпляра EnvDataReader.
    # Затем вы можете получить значения переменных окружения, например, значение переменной DP_HOST.
    print(env.get_value("DP_HOST"))

   ```
    В данном примере создается экземпляр `EnvDataReader`, где указывается путь к файлу `.env` вне корня проекта. Это демонстрирует способ использования `EnvDataReader` с пользовательским путем к файлу `.env`, который отличается от стандартного пути в корне проекта.

   ---   
   ```python
    # Можно также указать путь к файлу `.env` непосредственно при объявлении класса:

    from envdatareader import EnvDataReader

    # При создании экземпляра EnvDataReader сразу пропишем путь к файлу `.env` в его конструкторе:
    env = EnvDataReader(file_path="env\\.env")

    # Этот код демонстрирует создание экземпляра EnvDataReader с указанием пути к файлу `.env` внутри объявления класса.
    # Затем вы можете получить значения переменных окружения, например, значение переменной DP_HOST.
    print(env.get_value("DP_HOST"))

   ```

   В данном примере экземпляр `EnvDataReader` создается с указанием пути к файлу `.env` прямо в конструкторе класса. Это позволяет сразу при создании экземпляра указывать путь к файлу `.env`, который будет использоваться для работы с переменными окружения.

3. **Значение по умолчанию:**

   В случае, если значение переменной окружения отсутствует или не установлено в файле `.env`, можно установить значение по умолчанию. Пример:

   ```python
   from envdatareader import EnvDataReader

   # Создаем экземпляр EnvDataReader без указания пути к файлу .env
   env = EnvDataReader()

   # Получаем значение переменной, но если оно отсутствует, используем значение по умолчанию
   default_value = env.get_value("SOME_VARIABLE_NAME", default="DEFAULT_VALUE")
   print(default_value)
   ```

   Этот пример иллюстрирует способ использования `EnvDataReader` для извлечения значения переменной `SOME_VARIABLE_NAME` из файла `.env`. В случае, если данная переменная отсутствует или не имеет значения, установленного в файле, будет использовано значение по умолчанию, указанное как `DEFAULT_VALUE`. Такой механизм предоставляет гибкость в работе с переменными окружения, позволяя задавать значения по умолчанию для обеспечения более предсказуемой работы приложения, даже если некоторые переменные не были установлены или не найдены в файле `.env`.

4. **Управление переменными окружения:**

   В настоящее время `EnvDataReader` предоставляет возможности только для чтения значений переменных окружения из файла `.env`. Операции изменения или удаления переменных окружения непосредственно через `EnvDataReader` не поддерживаются в текущей версии библиотеки.

   В будущих версиях планируется расширение функциональности для управления переменными окружения, включая добавление, изменение и удаление переменных. При появлении обновлений вам будет доступна возможность более активно взаимодействовать с переменными окружения с помощью `EnvDataReader`.

5. **Использование переменных окружения в условиях:**

   Переменные окружения могут быть использованы для управления поведением вашего приложения в зависимости от среды исполнения или установленных настроек. Пример использования переменных окружения в условиях:

   ```python
   from envdatareader import EnvDataReader

   # Создаем экземпляр EnvDataReader для доступа к переменным окружения
   env = EnvDataReader()

   # Проверяем наличие переменной и выполняем определенные действия, если она установлена
   if env.get_value("DEBUG_MODE") == "True":
       # Выполняем действия в режиме отладки
       print("Debug mode is enabled.")
   else:
       # Выполняем обычные действия
       print("Running in standard mode.")
    ```
6. **Расширение и Наследование EnvDataReader**

   Библиотека EnvDataReader разработана с учетом гибкости и расширяемости, что позволяет легко наследовать ее и добавлять собственные функциональности, если вам нужно дополнительное поведение или поддержка специфических требований вашего проекта.

   6.1 **Наследование EnvDataReader**

   Чтобы наследовать `EnvDataReader` и добавить собственные функции, просто создайте новый класс, унаследованный от `EnvDataReader`, и добавьте свои методы. Например:

   ```python
   from envdatareader import EnvDataReader

   class MyEnvManager(EnvDataReader):
      def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)

      def my_custom_function(self):
         # Ваш собственный код и логика
         pass
   ```
   6.2 **Добавление новых методов**

   Вы можете легко добавить свои собственные методы к наследованному классу. Например, предположим, что вы хотите добавить метод для проверки наличия всех необходимых переменных окружения:

   ```python
   from envdatareader import EnvDataReader

   class MyEnvManager(EnvDataReader):
      def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)

      def check_required_variables(self, required_variables):
         for var in required_variables:
               if not self.get_value(var):
                  raise ValueError(f"Variable '{var}' is required but not set in the environment.")
   ```

   6.3 **Использование наследованных классов**

   После создания вашего наследованного класса, вы можете использовать его так же, как и оригинальный `EnvDataReader`. Вот пример:

   ```python
   from myenvmanager import MyEnvManager

   # Создаем экземпляр нашего наследованного класса
   my_env = MyEnvManager()

   # Используем стандартные методы EnvDataReader
   print(my_env.get_value("DP_HOST"))

   # Используем наши собственные методы
   my_env.check_required_variables(["API_KEY", "SECRET_KEY"])

   # Вызываем собственный метод
   my_env.my_custom_function()
   ```

   Таким образом, вы можете создать наследованный класс, который сочетает в себе функциональность `EnvDataReader` и ваши собственные уникальные возможности, что делает его более адаптивным к специфическим требованиям вашего проекта.





   
